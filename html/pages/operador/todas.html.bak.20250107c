<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>OGAAC Â· Operador Â· Todas las salas</title>
  
  <!-- CSS institucional base -->
  <link rel="stylesheet" href="/ogaac.css" />
  <!-- CSS especÃ­fico del Operador -->
  <link rel="stylesheet" href="/css/ogaac-operador.css" />
</head>
<body class="operador-page">

<header class="operador-header">
  <div class="operador-header-left">
    <div class="operador-header-title">OGAAC Â· Modo Operador</div>
    <div class="operador-header-subtitle" id="hdr-sub">Cargando configuraciÃ³nâ€¦</div>
  </div>
  <div class="operador-header-right">
    <a href="/operador/sedes.html" class="operador-toolbar-btn" style="text-decoration:none;">â† Volver a Sedes</a>
    <button id="warnings-pill" class="operador-warnings-trigger" hidden>âš ï¸ Advertencias</button>
    <div class="operador-header-health operador-mono" id="hdr-health"></div>
  </div>
</header>

<div class="operador-wrap">
  <div class="operador-toolbar">
    <button id="btn-refresh" class="operador-toolbar-btn">ğŸ”„ Refrescar</button>
    <button id="btn-pause" class="operador-toolbar-btn">â¸ Pausar polling</button>
    <input id="filter" class="operador-filter" placeholder="Filtrar (ej: suipacha, sala10, libertad...)" />
    <label class="operador-toggle">
      <input type="checkbox" id="toggle-force-poll" />
      <span>Forzar polling en deshabilitadas</span>
    </label>
    <label class="operador-toggle">
      <input type="checkbox" id="toggle-show-disabled" checked />
      <span>Mostrar deshabilitadas</span>
    </label>
  </div>
  <div id="grid" class="operador-grid"></div>
</div>

<div id="warnings-shell" class="operador-modal-shell" hidden>
  <div class="operador-modal" role="dialog" aria-labelledby="warnings-title" aria-modal="true">
    <div class="operador-modal-header">
      <div>
        <div class="operador-modal-title" id="warnings-title">Advertencias de configuraciÃ³n</div>
        <div class="operador-modal-subtitle" id="warnings-subtitle">Sin advertencias activas</div>
        <div class="operador-mono" id="warnings-counters" style="font-size:11px;color:#777;margin-top:4px;"></div>
      </div>
      <button class="operador-modal-close" id="warnings-close" aria-label="Cerrar">Ã—</button>
    </div>
    <div class="operador-modal-body" id="warnings-list">
      <div class="operador-warning-empty">Sin advertencias activas.</div>
    </div>
  </div>
</div>

<footer class="operador-footer">
  OGAAC Â· Modo Operador Â· Panel de control de salas
</footer>

<script>
  const POLL_MS = 5000;
  const NEED_AUTH_STATUS = new Set([401, 403]);
  const STORAGE_KEYS = {
    forcePoll: "ogaac_test_force_poll_disabled",
    showDisabled: "ogaac_test_show_disabled",
  };

  let paused = false;
  let allSalas = [];
  let lastRenderedCount = 0;
  const warningsState = { list: [], counts: {} };
  let warningsModalOpen = false;
  const uiPrefs = {
    forcePollDisabled: readBoolPref(STORAGE_KEYS.forcePoll, false),
    showDisabled: readBoolPref(STORAGE_KEYS.showDisabled, true),
  };

  const timers = new Map();      // key -> interval id
  const pendingPolls = new Set();// key -> in-flight
  let sessionPromise = null;

  function makeKey(sede, sala) { return `${sede}|${sala}`; }

  async function fetchJson(url, options = {}, { retryAuth = true } = {}) {
    const finalOptions = { credentials: "include", ...options };

    let response;
    try {
      response = await fetch(url, finalOptions);
    } catch (networkError) {
      const err = new Error(networkError?.message || "Error de red");
      err.status = 0;
      throw err;
    }

    let text = "";
    try { text = await response.text(); } catch (_) { text = ""; }

    let data = {};
    if (text) {
      try { data = JSON.parse(text); } catch (_) { data = {}; }
    }

    const isAppError = (data && typeof data === "object" && data.ok === false);
    if (!response.ok || isAppError) {
      const err = new Error(data.message || data.error || data.msg || `HTTP ${response.status}`);
      err.status = response.status;
      err.statusText = response.statusText;
      err.traceId = data.traceId;
      err.code = data.code || data.error;
      err.data = data;

      if (retryAuth && NEED_AUTH_STATUS.has(response.status)) {
        await requireSession();
        return fetchJson(url, options, { retryAuth: false });
      }
      throw err;
    }

    return data;
  }

  async function requireSession() {
    if (sessionPromise) return sessionPromise;

    sessionPromise = (async () => {
      if (await hasValidSession()) return true;
      await interactiveLogin();
      return true;
    })().finally(() => { sessionPromise = null; });

    return sessionPromise;
  }

  async function hasValidSession() {
    try {
      await fetchJson("/api/check", { method: "GET" }, { retryAuth: false });
      return true;
    } catch {
      return false;
    }
  }

  async function interactiveLogin() {
    const username = prompt("Usuario OGAAC:");
    if (!username) throw new Error("Login cancelado");

    const password = prompt(`ContraseÃ±a para ${username}:`);
    if (!password) throw new Error("Login cancelado");

    const payload = { username, password, user: username, pass: password };

    try {
      await fetchJson("/api/login", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      }, { retryAuth: false });
    } catch (err) {
      alert(err.message || "Login fallÃ³");
      throw err;
    }
  }

  function badge(text, cls = "") {
    const el = document.createElement("span");
    // Mapeo de clases viejas a nuevas
    const classMap = {
      "ok": "operador-badge--ok",
      "warn": "operador-badge--warn", 
      "err": "operador-badge--error",
      "disabled": "operador-badge--disabled"
    };
    const newCls = classMap[cls] || "";
    el.className = newCls ? `operador-badge ${newCls}` : "operador-badge";
    el.textContent = text;
    return el;
  }

  function mkCard(sede, sala, label) {
    const card = document.createElement("div");
    card.className = "operador-card";
    card.dataset.sede = sede;
    card.dataset.sala = sala;

    const top = document.createElement("div");
    top.className = "operador-card-top";

    const left = document.createElement("div");

    const t = document.createElement("div");
    t.className = "operador-card-title";
    t.textContent = (label ? `${label} Â· ` : "") + `${sede} / ${sala}`;

    const sub = document.createElement("div");
    sub.className = "operador-card-endpoint";
    sub.textContent = `/api/obs/${sede}/${sala}/summary`;

    left.appendChild(t);
    left.appendChild(sub);

    const right = document.createElement("div");
    right.className = "operador-card-status";
    right.textContent = "â€¦";

    top.appendChild(left);
    top.appendChild(right);

    const badges = document.createElement("div");
    badges.className = "operador-badges";

    const configRow = document.createElement("div");
    configRow.className = "operador-card-config operador-mono";

    const warningBadges = document.createElement("div");
    warningBadges.className = "operador-badges";

    const row1 = document.createElement("div");
    row1.className = "operador-card-row";

    const row2 = document.createElement("div");
    row2.className = "operador-card-row";

    card.appendChild(top);
    card.appendChild(badges);
    card.appendChild(configRow);
    card.appendChild(warningBadges);
    card.appendChild(row1);
    card.appendChild(row2);

    const actions = document.createElement("div");
    actions.className = "operador-card-actions";
    card.appendChild(actions);

    return { card, topRight: right, badges, row1, row2, subline: sub, configRow, warningBadges, actions };
  }

  function renderDisabledCard(ui, cfg = {}) {
    if (!ui || !ui.card) return;
    ui.card.classList.add("operador-card--disabled");
    ui.topRight.textContent = "Polling inactivo";
    if (ui.subline) ui.subline.textContent = cfg.ws || "Sin endpoint OBS configurado";
    ui.badges.innerHTML = "";
    ui.badges.appendChild(badge("Polling deshabilitado", "disabled"));
    ui.row1.textContent = "Habilitar modo test para forzar polling.";
    ui.row2.textContent = cfg.ws ? `ws=${cfg.ws}` : "";
  }

  function createPlaceholderCard(title, rows = []) {
    const card = document.createElement("div");
    card.className = "operador-card";

    const t = document.createElement("div");
    t.className = "operador-card-title";
    t.textContent = title;
    card.appendChild(t);

    rows.forEach((text) => {
      const row = document.createElement("div");
      row.className = "operador-card-row";
      row.textContent = text;
      card.appendChild(row);
    });

    return card;
  }

  function updateHeaderCounts(shown) {
    lastRenderedCount = shown;
    const hdr = document.getElementById("hdr-sub");
    const pauseNote = paused ? " Â· PAUSADO" : "";
    hdr.textContent = `Total: ${allSalas.length} Â· Mostradas: ${shown} Â· Poll: ${POLL_MS / 1000}s${pauseNote}`;
  }

  function showGridError(err) {
    const grid = document.getElementById("grid");
    grid.innerHTML = "";

    const rows = [
      (err.status ? `status=${err.status}` : null),
      (err.code ? `code=${err.code}` : null),
      (err.traceId ? `traceId=${err.traceId}` : null),
      (err.message ? `msg=${err.message}` : "Error desconocido"),
    ].filter(Boolean);

    grid.appendChild(createPlaceholderCard("No se pudo cargar la configuraciÃ³n", rows));
    updateHeaderCounts(0);
  }

  function renderList(list) {
    const grid = document.getElementById("grid");
    grid.innerHTML = "";

    timers.forEach((id) => clearInterval(id));
    timers.clear();
    pendingPolls.clear();

    if (!list.length) {
      const hasFilter = (document.getElementById("filter").value || "").trim().length > 0;
      const msg = hasFilter ? "Sin salas que coincidan con el filtro" : "Sin salas configuradas";
      grid.appendChild(createPlaceholderCard(msg));
      updateHeaderCounts(0);
      return;
    }

    list.forEach((item) => {
      const { sede, sala, label, enabled = true } = item;
      const ui = mkCard(sede, sala, label);
      grid.appendChild(ui.card);
      decorateCardConfig(ui, item);
      setupCardActions(ui, item);
      const allowPolling = shouldPollRoom(item);
      if (!allowPolling) {
        renderDisabledCard(ui, item);
        return;
      }
      if (enabled === false) ui.card.classList.add("card-disabled");
      const key = makeKey(sede, sala);

      const tick = async () => {
        if (paused || pendingPolls.has(key)) return;
        pendingPolls.add(key);

        try {
          const data = await fetchJson(`/api/obs/${encodeURIComponent(sede)}/${encodeURIComponent(sala)}/summary`);
          ui.topRight.textContent = data.traceId || "";

          ui.badges.innerHTML = "";
          const streamOn = !!data.stream?.outputActive;
          const recOn = !!data.record?.outputActive;
          const op = data.state?.state || "unknown";

          ui.badges.appendChild(badge(`STREAM: ${streamOn ? "ON" : "OFF"}`, streamOn ? "ok" : ""));
          ui.badges.appendChild(badge(`RECORD: ${recOn ? "ON" : "OFF"}`, recOn ? "warn" : ""));
          ui.badges.appendChild(badge(`OP: ${op}`, op === "error" ? "err" : (op === "recording" ? "warn" : "ok")));

          const lastOut = data.state?.lastOutputPath;
          const lastErr = data.state?.lastError;
          ui.row1.textContent = lastOut ? `lastOutputPath=${lastOut}` : "";
          ui.row2.textContent = lastErr ? `lastError=${lastErr}` : "";
        } catch (err) {
          const statusLabel = err.status ? `HTTP ${err.status}` : "ERROR";
          ui.topRight.textContent = err.traceId ? `traceId=${err.traceId}` : statusLabel;

          ui.badges.innerHTML = "";
          ui.badges.appendChild(badge(statusLabel, "err"));
          if (err.traceId) ui.badges.appendChild(badge(`traceId=${err.traceId}`, "err"));
          if (err.code) ui.badges.appendChild(badge(`code=${err.code}`, "err"));

          ui.row1.textContent = err.message ? `msg=${err.message}` : "";
          ui.row2.textContent = err.statusText ? err.statusText : "";
        } finally {
          pendingPolls.delete(key);
        }
      };

      tick();
      timers.set(key, setInterval(tick, POLL_MS));
    });

    updateHeaderCounts(list.length);
  }

  function decorateCardConfig(ui, cfg = {}) {
    if (!ui) return;
    const enabled = cfg.enabled !== false;
    const detail = [];
    detail.push(`enabled=${enabled}`);
    if (typeof cfg.needsSecrets === "boolean") detail.push(`needsSecrets=${cfg.needsSecrets}`);
    if (cfg.ws) detail.push(`ws=${cfg.ws}`);
    if (ui.configRow) ui.configRow.textContent = detail.join(" Â· ");
    if (ui.warningBadges) {
      ui.warningBadges.innerHTML = "";
      if (!enabled) {
        ui.warningBadges.appendChild(badge("DESHABILITADA", "disabled"));
      }
      if (cfg.needsSecrets) {
        ui.warningBadges.appendChild(badge("needsSecrets", "warn"));
      }
      const warnings = Array.isArray(cfg.warnings) ? cfg.warnings : [];
      warnings.forEach((warn) => {
        const label = formatWarningLabel(warn);
        const warnBadge = badge(label, "warn");
        if (warn && typeof warn === "object") {
          const msg = warn.message || warn.detail;
          if (msg) warnBadge.title = msg;
        }
        ui.warningBadges.appendChild(warnBadge);
      });
    }
    if (ui.subline) {
      if (cfg.ws) ui.subline.textContent = cfg.ws;
      else if (cfg.sede && cfg.sala) ui.subline.textContent = `/api/obs/${cfg.sede}/${cfg.sala}/summary`;
    }
  }

  function formatWarningLabel(warn) {
    if (!warn) return "warning";
    if (typeof warn === "string") return warn;
    if (warn.code) return warn.code;
    if (warn.id) return String(warn.id);
    return warn.message ? warn.message.slice(0, 36) : "warning";
  }

  function shouldPollRoom(item = {}) {
    return item.enabled !== false || uiPrefs.forcePollDisabled;
  }

  function setupCardActions(ui, item) {
    if (!ui || !ui.actions) return;
    ui.actions.innerHTML = "";

    const controlBtn = document.createElement("button");
    controlBtn.className = "operador-card-btn operador-card-btn--primary";
    controlBtn.textContent = "ğŸ¬ Abrir Sala";
    controlBtn.addEventListener("click", () => openControlPanel(item));
    ui.actions.appendChild(controlBtn);

    const wsBtn = document.createElement("button");
    wsBtn.className = "operador-card-btn";
    wsBtn.textContent = "âš™ï¸ WebSocket OBS";
    wsBtn.addEventListener("click", () => openWebSocketObs(item));
    ui.actions.appendChild(wsBtn);
  }

  function buildControlUrl(item = {}) {
    const sede = encodeURIComponent(item.sede || "");
    const sala = encodeURIComponent(item.sala || "");
    // Corregido: apuntar a /operador/ (no /pages/operador/)
    return `/operador/${sede}/${sala}/index.html`;
  }

  async function openControlPanel(item) {
    const target = buildControlUrl(item);
    // NavegaciÃ³n directa sin popup about:blank
    try {
      const res = await fetch(target, { method: "HEAD", credentials: "include", cache: "no-cache" });
      if (res.ok) {
        window.location.href = target;
        return;
      }
      throw new Error("not-found");
    } catch (err) {
      alert("No existe UI para esta sala. Verificar que existe: " + target);
    }
  }

  function openWebSocketObs(item) {
    const sede = encodeURIComponent(item.sede || "");
    const sala = encodeURIComponent(item.sala || "");
    const url = `/web-socket-obs/?sede=${sede}&sala=${sala}`;
    window.open(url, "_blank", "noopener");
  }

  // Config warnings badge + modal
  function updateWarningsUi(warnings = [], counts = {}) {
    warningsState.list = Array.isArray(warnings) ? warnings : [];
    warningsState.counts = counts && typeof counts === "object" ? counts : {};

    const btn = document.getElementById("warnings-pill");
    const total = warningsState.list.length;
    if (btn) {
      btn.hidden = total === 0;
      if (total) {
        const label = total === 1 ? "advertencia" : "advertencias";
        btn.textContent = `âš ï¸ ${total} ${label}`;
        btn.setAttribute("aria-label", `Hay ${total} ${label} de configuraciÃ³n`);
      } else {
        btn.textContent = "âš ï¸ Advertencias";
        btn.removeAttribute("aria-label");
        if (warningsModalOpen) closeWarningsModal();
      }
    }

    const subtitle = document.getElementById("warnings-subtitle");
    if (subtitle) {
      subtitle.textContent = total
        ? `${total} advertencia${total === 1 ? "" : "s"} activa${total === 1 ? "" : "s"}`
        : "Sin advertencias activas";
    }

    const countersEl = document.getElementById("warnings-counters");
    if (countersEl) {
      const summary = formatWarningCounters(warningsState.counts);
      countersEl.textContent = summary || "";
    }

    renderWarningsModal();
  }

  function renderWarningsModal() {
    const listEl = document.getElementById("warnings-list");
    if (!listEl) return;

    listEl.innerHTML = "";
    if (!warningsState.list.length) {
      const empty = document.createElement("div");
      empty.className = "operador-warning-empty";
      empty.textContent = "Sin advertencias activas.";
      listEl.appendChild(empty);
      return;
    }

    warningsState.list.forEach((warn) => {
      const item = document.createElement("div");
      item.className = "operador-warning-item";

      const head = document.createElement("div");
      head.className = "operador-warning-head";

      const codePill = document.createElement("span");
      codePill.className = "operador-badge operador-badge--warn";
      codePill.textContent = warn.code || "warning";
      head.appendChild(codePill);

      const metaText = buildWarningMeta(warn);
      if (metaText) {
        const meta = document.createElement("span");
        meta.className = "operador-warning-meta";
        meta.textContent = metaText;
        head.appendChild(meta);
      }

      item.appendChild(head);

      const msg = document.createElement("div");
      msg.className = "operador-warning-message";
      msg.textContent = warn.message || "Sin detalles";
      item.appendChild(msg);

      if (Array.isArray(warn.ids) && warn.ids.length > 1) {
        const ids = document.createElement("div");
        ids.className = "operador-warning-meta";
        ids.textContent = "IDs: " + warn.ids.join(", ");
        item.appendChild(ids);
      }

      listEl.appendChild(item);
    });
  }

  function buildWarningMeta(warn) {
    if (!warn || typeof warn !== "object") return "";
    const segments = [];
    if (warn.id) segments.push(String(warn.id));
    if (warn.value) segments.push(String(warn.value));
    if (Array.isArray(warn.ids) && warn.ids.length === 1) segments.push(String(warn.ids[0]));
    return segments.join(" Â· ");
  }

  function formatWarningCounters(counts) {
    if (!counts || typeof counts !== "object") return "";
    const mapping = [
      ["missingSecrets", "sin secretos"],
      ["duplicateObsWs", "OBS duplicado"],
      ["duplicateRtsp", "RTSP duplicado"],
    ];
    const parts = [];
    mapping.forEach(([key, label]) => {
      const value = counts[key];
      if (typeof value === "number" && value > 0) {
        parts.push(`${label}: ${value}`);
      }
    });
    return parts.join(" Â· ");
  }

  function openWarningsModal() {
    if (!warningsState.list.length) return;
    const shell = document.getElementById("warnings-shell");
    if (!shell) return;
    renderWarningsModal();
    shell.hidden = false;
    shell.classList.add("open");
    document.body.classList.add("modal-open");
    warningsModalOpen = true;
  }

  function closeWarningsModal() {
    const shell = document.getElementById("warnings-shell");
    if (!shell || shell.hidden) {
      warningsModalOpen = false;
      document.body.classList.remove("modal-open");
      return;
    }
    shell.classList.remove("open");
    shell.hidden = true;
    document.body.classList.remove("modal-open");
    warningsModalOpen = false;
  }

  async function loadConfig() {
    const hdr = document.getElementById("hdr-sub");
    hdr.textContent = "Actualizando listaâ€¦";

    try {
      const data = await fetchJson("/api/obs/config");
      allSalas = Array.isArray(data.salas) ? data.salas : [];
      updateWarningsUi(data.warnings || [], data.counts || {});
      applyFilter();
    } catch (err) {
      console.error("[operador] No pude cargar /api/obs/config", err);
      showGridError(err);
      throw err;
    }
  }

  function applyFilter() {
    const q = (document.getElementById("filter").value || "").toLowerCase().trim();
    let filtered = !q ? allSalas : allSalas.filter((x) =>
      (x.sede || "").toLowerCase().includes(q) ||
      (x.sala || "").toLowerCase().includes(q) ||
      String(x.label || "").toLowerCase().includes(q)
    );
    if (!uiPrefs.showDisabled) {
      filtered = filtered.filter((x) => x.enabled !== false);
    }
    renderList(filtered);
  }

  async function loadHealth() {
    try {
      const h = await fetchJson("/health", {}, { retryAuth: false });
      document.getElementById("hdr-health").textContent =
        `rev=${h.gitRev || "-"} Â· up=${h.uptimeSec || 0}s Â· obsPool=${h.obsPoolSize} Â· recOps=${h.recordOpsSize}`;
    } catch {
      document.getElementById("hdr-health").textContent = "";
    }
  }

  document.getElementById("btn-refresh").addEventListener("click", () => { loadConfig().catch(() => {}); });

  document.getElementById("btn-pause").addEventListener("click", (e) => {
    paused = !paused;
    e.target.textContent = paused ? "Reanudar polling" : "Pausar polling";
    updateHeaderCounts(lastRenderedCount);
  });

  document.getElementById("filter").addEventListener("input", applyFilter);

  const toggleForce = document.getElementById("toggle-force-poll");
  if (toggleForce) {
    toggleForce.checked = uiPrefs.forcePollDisabled;
    toggleForce.addEventListener("change", (event) => {
      uiPrefs.forcePollDisabled = event.target.checked;
      writeBoolPref(STORAGE_KEYS.forcePoll, uiPrefs.forcePollDisabled);
      applyFilter();
    });
  }

  const toggleShowDisabled = document.getElementById("toggle-show-disabled");
  if (toggleShowDisabled) {
    toggleShowDisabled.checked = uiPrefs.showDisabled;
    toggleShowDisabled.addEventListener("change", (event) => {
      uiPrefs.showDisabled = event.target.checked;
      writeBoolPref(STORAGE_KEYS.showDisabled, uiPrefs.showDisabled);
      applyFilter();
    });
  }

  const warningsButton = document.getElementById("warnings-pill");
  if (warningsButton) {
    warningsButton.addEventListener("click", openWarningsModal);
  }

  const warningsClose = document.getElementById("warnings-close");
  if (warningsClose) {
    warningsClose.addEventListener("click", closeWarningsModal);
  }

  const warningsShell = document.getElementById("warnings-shell");
  if (warningsShell) {
    warningsShell.addEventListener("click", (event) => {
      if (event.target === warningsShell) closeWarningsModal();
    });
  }

  window.addEventListener("keydown", (event) => {
    if (event.key === "Escape" && warningsModalOpen) {
      closeWarningsModal();
    }
  });

  function readBoolPref(key, fallback) {
    try {
      const raw = localStorage.getItem(key);
      if (raw === null) return fallback;
      return raw === "true";
    } catch (err) {
      console.warn("[operador] No pude leer localStorage", err);
      return fallback;
    }
  }

  function writeBoolPref(key, value) {
    try {
      localStorage.setItem(key, value ? "true" : "false");
    } catch (err) {
      console.warn("[operador] No pude persistir localStorage", err);
    }
  }

  (async function init() {
    await requireSession().catch((err) => { console.warn("[operador] SesiÃ³n no iniciada aÃºn", err); });
    await loadHealth();
    await loadConfig().catch(() => {});
    setInterval(loadHealth, 5000);
  })();
</script>
</body>
</html>
